{
  "version": 3,
  "sources": ["../../dom-to-image-more/src/dom-to-image-more.js"],
  "sourcesContent": ["(function (global) {\n    'use strict';\n\n    const util = newUtil();\n    const inliner = newInliner();\n    const fontFaces = newFontFaces();\n    const images = newImages();\n\n    // Default impl options\n    const defaultOptions = {\n        // Default is to fail on error, no placeholder\n        imagePlaceholder: undefined,\n        // Default cache bust is false, it will use the cache\n        cacheBust: false,\n        // Use (existing) authentication credentials for external URIs (CORS requests)\n        useCredentials: false,\n        // Default resolve timeout\n        httpTimeout: 30000\n    };\n\n    const domtoimage = {\n        toSvg: toSvg,\n        toPng: toPng,\n        toJpeg: toJpeg,\n        toBlob: toBlob,\n        toPixelData: toPixelData,\n        toCanvas: toCanvas,\n        impl: {\n            fontFaces: fontFaces,\n            images: images,\n            util: util,\n            inliner: inliner,\n            urlCache: [],\n            options: {}\n        }\n    };\n\n    if (typeof exports === \"object\" && typeof module === \"object\") {\n        module.exports = domtoimage;\n    } else {\n        global.domtoimage = domtoimage;\n    }\n\n    // support node and browsers\n    const getComputedStyle = global.getComputedStyle || window.getComputedStyle;\n    const atob = global.atob || window.atob;\n\n    /**\n     * @param {Node} node - The DOM Node object to render\n     * @param {Object} options - Rendering options\n     * @param {Function} options.filter - Should return true if passed node should be included in the output\n     *          (excluding node means excluding it's children as well). Not called on the root node.\n     * @param {Function} options.onclone - Callback function which is called when the Document has been cloned for\n     *         rendering, can be used to modify the contents that will be rendered without affecting the original\n     *         source document.\n     * @param {String} options.bgcolor - color for the background, any valid CSS color value.\n     * @param {Number} options.width - width to be applied to node before rendering.\n     * @param {Number} options.height - height to be applied to node before rendering.\n     * @param {Object} options.style - an object whose properties to be copied to node's style before rendering.\n     * @param {Number} options.quality - a Number between 0 and 1 indicating image quality (applicable to JPEG only),\n                defaults to 1.0.\n     * @param {Number} options.scale - a Number multiplier to scale up the canvas before rendering to reduce fuzzy images, defaults to 1.0.\n     * @param {String} options.imagePlaceholder - dataURL to use as a placeholder for failed images, default behaviour is to fail fast on images we can't fetch\n     * @param {Boolean} options.cacheBust - set to true to cache bust by appending the time to the request url\n     * @return {Promise} - A promise that is fulfilled with a SVG image data URL\n     * */\n    function toSvg(node, options) {\n        const ownerWindow = domtoimage.impl.util.getWindow(node);\n        options = options || {};\n        copyOptions(options);\n        return Promise.resolve(node)\n            .then(function (clonee) {\n                const root = true;\n                return cloneNode(clonee, options.filter, root, null, ownerWindow);\n            })\n            .then(embedFonts)\n            .then(inlineImages)\n            .then(applyOptions)\n            .then(function (clone) {\n                return makeSvgDataUri(clone,\n                    options.width || util.width(node),\n                    options.height || util.height(node)\n                );\n            })\n            .then(clearCache);\n\n        function clearCache(result) {\n            domtoimage.impl.urlCache = [];\n            removeSandbox();\n            return result;\n        }\n\n        function applyOptions(clone) {\n            if (options.bgcolor) { clone.style.backgroundColor = options.bgcolor; }\n            if (options.width) { clone.style.width = `${options.width}px`; }\n            if (options.height) { clone.style.height = `${options.height}px`; }\n\n            if (options.style) {\n                Object.keys(options.style).forEach(function (property) {\n                    clone.style[property] = options.style[property];\n                });\n            }\n\n            let onCloneResult = null;\n\n            if (typeof options.onclone === \"function\") {\n                onCloneResult = options.onclone(clone);\n            }\n\n            return Promise.resolve(onCloneResult)\n                .then(function () {\n                    return clone;\n                });\n        }\n    }\n\n    /**\n     * @param {Node} node - The DOM Node object to render\n     * @param {Object} options - Rendering options, @see {@link toSvg}\n     * @return {Promise} - A promise that is fulfilled with a Uint8Array containing RGBA pixel data.\n     * */\n    function toPixelData(node, options) {\n        return draw(node, options)\n            .then(function (canvas) {\n                return canvas.getContext('2d').getImageData(\n                    0,\n                    0,\n                    util.width(node),\n                    util.height(node)\n                ).data;\n            });\n    }\n\n    /**\n     * @param {Node} node - The DOM Node object to render\n     * @param {Object} options - Rendering options, @see {@link toSvg}\n     * @return {Promise} - A promise that is fulfilled with a PNG image data URL\n     * */\n    function toPng(node, options) {\n        return draw(node, options)\n            .then(function (canvas) {\n                return canvas.toDataURL();\n            });\n    }\n\n    /**\n     * @param {Node} node - The DOM Node object to render\n     * @param {Object} options - Rendering options, @see {@link toSvg}\n     * @return {Promise} - A promise that is fulfilled with a JPEG image data URL\n     * */\n    function toJpeg(node, options) {\n        return draw(node, options)\n            .then(function (canvas) {\n                return canvas.toDataURL('image/jpeg', (options ? options.quality : undefined) || 1.0);\n            });\n    }\n\n    /**\n     * @param {Node} node - The DOM Node object to render\n     * @param {Object} options - Rendering options, @see {@link toSvg}\n     * @return {Promise} - A promise that is fulfilled with a PNG image blob\n     * */\n    function toBlob(node, options) {\n        return draw(node, options)\n            .then(util.canvasToBlob);\n    }\n\n    /**\n     * @param {Node} node - The DOM Node object to render\n     * @param {Object} options - Rendering options, @see {@link toSvg}\n     * @return {Promise} - A promise that is fulfilled with a canvas object\n     * */\n    function toCanvas(node, options) {\n        return draw(node, options);\n    }\n\n    function copyOptions(options) {\n        // Copy options to impl options for use in impl\n        if (typeof (options.imagePlaceholder) === 'undefined') {\n            domtoimage.impl.options.imagePlaceholder = defaultOptions.imagePlaceholder;\n        } else {\n            domtoimage.impl.options.imagePlaceholder = options.imagePlaceholder;\n        }\n\n        if (typeof (options.cacheBust) === 'undefined') {\n            domtoimage.impl.options.cacheBust = defaultOptions.cacheBust;\n        } else {\n            domtoimage.impl.options.cacheBust = options.cacheBust;\n        }\n\n        if (typeof (options.useCredentials) === 'undefined') {\n            domtoimage.impl.options.useCredentials = defaultOptions.useCredentials;\n        } else {\n            domtoimage.impl.options.useCredentials = options.useCredentials;\n        }\n\n        if (typeof (options.httpTimeout) === 'undefined') {\n            domtoimage.impl.options.httpTimeout = defaultOptions.httpTimeout;\n        } else {\n            domtoimage.impl.options.httpTimeout = options.httpTimeout;\n        }\n    }\n\n    function draw(domNode, options) {\n        options = options || {};\n        return toSvg(domNode, options)\n            .then(util.makeImage)\n            .then(util.delay(0))\n            .then(function (image) {\n                const scale = typeof (options.scale) !== 'number' ? 1 : options.scale;\n                const canvas = newCanvas(domNode, scale);\n                const ctx = canvas.getContext('2d');\n                ctx.msImageSmoothingEnabled = false;\n                ctx.imageSmoothingEnabled = false;\n                if (image) {\n                    ctx.scale(scale, scale);\n                    ctx.drawImage(image, 0, 0);\n                }\n                return canvas;\n            });\n\n        function newCanvas(node, scale) {\n            const canvas = document.createElement('canvas');\n            canvas.width = (options.width || util.width(node)) * scale;\n            canvas.height = (options.height || util.height(node)) * scale;\n\n            if (options.bgcolor) {\n                const ctx = canvas.getContext('2d');\n                ctx.fillStyle = options.bgcolor;\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n            }\n\n            return canvas;\n        }\n    }\n\n    function cloneNode(node, filter, root, parentComputedStyles, ownerWindow) {\n        // NEVER clone SCRIPT blocks and if not at root, and there's a filter\n        // ignore anything for which filter returns falsey\n        if (node.tagName === 'SCRIPT'\n            || (!root && filter && !filter(node))) {\n            return Promise.resolve();\n        }\n\n        return Promise.resolve(node)\n            .then(makeNodeCopy)\n            .then(function (clone) {\n                return cloneChildren(node, clone);\n            })\n            .then(function (clone) {\n                return processClone(node, clone);\n            });\n\n        function makeNodeCopy(original) {\n            return util.isHTMLCanvasElement(original)\n                ? util.makeImage(original.toDataURL())\n                : original.cloneNode(false);\n        }\n\n        function cloneChildren(original, clone) {\n            const children = original.childNodes;\n            if (children.length === 0) {\n                return Promise.resolve(clone);\n            }\n\n            return cloneChildrenInOrder(clone, util.asArray(children))\n                .then(function () {\n                    return clone;\n                });\n\n            function cloneChildrenInOrder(parent, childs) {\n                const computedStyles = getComputedStyle(original);\n                let done = Promise.resolve();\n                childs.forEach(function (child) {\n                    done = done\n                        .then(function () {\n                            return cloneNode(child, filter, false, computedStyles, ownerWindow);\n                        })\n                        .then(function (childClone) {\n                            if (childClone) { parent.appendChild(childClone); }\n                        });\n                });\n                return done;\n            }\n        }\n\n        function processClone(original, clone) {\n            if (!util.isElement(clone)) { return clone; }\n\n            return Promise.resolve()\n                .then(cloneStyle)\n                .then(clonePseudoElements)\n                .then(copyUserInput)\n                .then(fixSvg)\n                .then(function () {\n                    return clone;\n                });\n\n            function cloneStyle() {\n                copyStyle(original, clone);\n\n                function copyFont(source, target) {\n                    target.font = source.font;\n                    target.fontFamily = source.fontFamily;\n                    target.fontFeatureSettings = source.fontFeatureSettings;\n                    target.fontKerning = source.fontKerning;\n                    target.fontSize = source.fontSize;\n                    target.fontStretch = source.fontStretch;\n                    target.fontStyle = source.fontStyle;\n                    target.fontVariant = source.fontVariant;\n                    target.fontVariantCaps = source.fontVariantCaps;\n                    target.fontVariantEastAsian = source.fontVariantEastAsian;\n                    target.fontVariantLigatures = source.fontVariantLigatures;\n                    target.fontVariantNumeric = source.fontVariantNumeric;\n                    target.fontVariationSettings = source.fontVariationSettings;\n                    target.fontWeight = source.fontWeight;\n                }\n\n                function copyStyle(sourceElement, targetElement) {\n                    const sourceComputedStyles = getComputedStyle(sourceElement);\n                    if (sourceComputedStyles.cssText) {\n                        targetElement.style.cssText = sourceComputedStyles.cssText;\n                        copyFont(sourceComputedStyles, targetElement.style); // here we re-assign the font props.\n                    } else {\n                        copyUserComputedStyleFast(sourceComputedStyles, parentComputedStyles, targetElement);\n\n                        // Remove positioning of root elements, which stops them from being captured correctly\n                        if (root) {\n                            ['inset-block', 'inset-block-start', 'inset-block-end']\n                                .forEach((prop) => targetElement.style.removeProperty(prop));\n                            ['left', 'right', 'top', 'bottom'].forEach((prop) => {\n                                if (targetElement.style.getPropertyValue(prop)) {\n                                    targetElement.style.setProperty(prop, '0px');\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n\n            function clonePseudoElements() {\n                const cloneClassName = util.uid();\n\n                [':before', ':after'].forEach(function (element) {\n                    clonePseudoElement(element);\n                });\n\n                function clonePseudoElement(element) {\n                    const style = getComputedStyle(original, element);\n                    const content = style.getPropertyValue('content');\n\n                    if (content === '' || content === 'none') { return; }\n\n                    const currentClass = clone.getAttribute('class') || '';\n                    clone.setAttribute('class', `${currentClass} ${cloneClassName}`);\n\n                    const styleElement = document.createElement('style');\n                    styleElement.appendChild(formatPseudoElementStyle());\n                    clone.appendChild(styleElement);\n\n                    function formatPseudoElementStyle() {\n                        const selector = `.${cloneClassName}:${element}`;\n                        const cssText = style.cssText ? formatCssText() : formatCssProperties();\n                        return document.createTextNode(`${selector}{${cssText}}`);\n\n                        function formatCssText() {\n                            return `${style.cssText} content: ${content};`;\n                        }\n\n                        function formatCssProperties() {\n                            const styleText = util.asArray(style)\n                                .map(formatProperty)\n                                .join('; ');\n                            return `${styleText};`;\n\n                            function formatProperty(name) {\n                                const propertyValue = style.getPropertyValue(name);\n                                const propertyPriority = style.getPropertyPriority(name) ? ' !important' : '';\n                                return `${name}: ${propertyValue}${(propertyPriority)}`;\n                            }\n                        }\n                    }\n                }\n            }\n\n            function copyUserInput() {\n                if (util.isHTMLTextAreaElement(original)) { clone.innerHTML = original.value; }\n                if (util.isHTMLInputElement(original)) { clone.setAttribute(\"value\", original.value); }\n            }\n\n            function fixSvg() {\n                if (util.isSVGElement(clone)) {\n                    clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n\n                    if (util.isSVGRectElement(clone)) {\n                        ['width', 'height'].forEach(function (attribute) {\n                            const value = clone.getAttribute(attribute);\n                            if (value) {\n                                clone.style.setProperty(attribute, value);\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    function embedFonts(node) {\n        return fontFaces.resolveAll()\n            .then(function (cssText) {\n                if (cssText !== '') {\n                    const styleNode = document.createElement('style');\n                    node.appendChild(styleNode);\n                    styleNode.appendChild(document.createTextNode(cssText));\n                }\n                return node;\n            });\n    }\n\n    function inlineImages(node) {\n        return images.inlineAll(node)\n            .then(function () {\n                return node;\n            });\n    }\n\n    function makeSvgDataUri(node, width, height) {\n        return Promise.resolve(node)\n            .then(function (svg) {\n                svg.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');\n                return new XMLSerializer().serializeToString(svg);\n            })\n            .then(util.escapeXhtml)\n            .then(function (xhtml) {\n                return `<foreignObject x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">${xhtml}</foreignObject>`;\n            })\n            .then(function (foreignObject) {\n                return `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${width}\" height=\"${height}\">${foreignObject}</svg>`;\n            })\n            .then(function (svg) {\n                return `data:image/svg+xml;charset=utf-8,${svg}`;\n            });\n    }\n\n    function newUtil() {\n        let uid_index = 0;\n\n        return {\n            escape: escapeRegEx,\n            isDataUrl: isDataUrl,\n            canvasToBlob: canvasToBlob,\n            resolveUrl: resolveUrl,\n            getAndEncode: getAndEncode,\n            uid: uid,\n            delay: delay,\n            asArray: asArray,\n            escapeXhtml: escapeXhtml,\n            makeImage: makeImage,\n            width: width,\n            height: height,\n            getWindow: getWindow,\n            isElement: isElement,\n            isHTMLElement: isHTMLElement,\n            isHTMLCanvasElement: isHTMLCanvasElement,\n            isHTMLInputElement: isHTMLInputElement,\n            isHTMLImageElement: isHTMLImageElement,\n            isHTMLTextAreaElement: isHTMLTextAreaElement,\n            isSVGElement: isSVGElement,\n            isSVGRectElement: isSVGRectElement\n        };\n\n        function getWindow(node) {\n            const ownerDocument = node ? node.ownerDocument : undefined;\n            return (ownerDocument ? ownerDocument.defaultView : undefined) || global || window;\n        }\n\n        function isElement(value) {\n            return value instanceof getWindow(value).Element;\n        }\n\n        function isHTMLCanvasElement(value) {\n            return value instanceof getWindow(value).HTMLCanvasElement;\n        }\n\n        function isHTMLElement(value) {\n            return value instanceof getWindow(value).HTMLElement;\n        }\n\n        function isHTMLImageElement(value) {\n            return value instanceof getWindow(value).HTMLImageElement;\n        }\n\n        function isHTMLInputElement(value) {\n            return value instanceof getWindow(value).HTMLInputElement;\n        }\n\n        function isSVGElement(value) {\n            return value instanceof getWindow(value).SVGElement;\n        }\n\n        function isSVGRectElement(value) {\n            return value instanceof getWindow(value).SVGRectElement;\n        }\n\n        function isHTMLTextAreaElement(value) {\n            return value instanceof getWindow(value).HTMLTextAreaElement;\n        }\n\n        function isDataUrl(url) {\n            return url.search(/^(data:)/) !== -1;\n        }\n\n        function asBlob(canvas) {\n            return new Promise(function (resolve) {\n                const binaryString = atob(canvas.toDataURL().split(',')[1]);\n                const length = binaryString.length;\n                const binaryArray = new Uint8Array(length);\n\n                for (let i = 0; i < length; i++) {\n                    binaryArray[i] = binaryString.charCodeAt(i);\n                }\n\n                resolve(new Blob([binaryArray], {\n                    type: 'image/png'\n                }));\n            });\n        }\n\n        function canvasToBlob(canvas) {\n            if (canvas.toBlob) {\n                return new Promise(function (resolve) {\n                    canvas.toBlob(resolve);\n                });\n            }\n\n            return asBlob(canvas);\n        }\n\n        function resolveUrl(url, baseUrl) {\n            const doc = document.implementation.createHTMLDocument();\n            const base = doc.createElement('base');\n            doc.head.appendChild(base);\n            const a = doc.createElement('a');\n            doc.body.appendChild(a);\n            base.href = baseUrl;\n            a.href = url;\n            return a.href;\n        }\n\n        function uid() {\n            return `u${fourRandomChars()}${uid_index++}`;\n\n            function fourRandomChars() {\n                /* see https://stackoverflow.com/a/6248722/2519373 */\n                return (`0000${(Math.random() * Math.pow(36, 4) << 0).toString(36)}`).slice(-4);\n            }\n        }\n\n        function makeImage(uri) {\n            if (uri === 'data:,') { return Promise.resolve(); }\n\n            return new Promise(function (resolve, reject) {\n                const image = new Image();\n                if (domtoimage.impl.options.useCredentials) {\n                    image.crossOrigin = 'use-credentials';\n                }\n                image.onload = function () {\n                    if (window && window.requestAnimationFrame) {\n                        // In order to work around a Firefox bug (webcompat/web-bugs#119834) we\n                        // need to wait one extra frame before it's safe to read the image data.\n                        window.requestAnimationFrame(function () {\n                            resolve(image);\n                        });\n                    } else {\n                        // If we don't have a window or requestAnimationFrame function proceed immediately.\n                        resolve(image);\n                    }\n                };\n                image.onerror = reject;\n                image.src = uri;\n            });\n        }\n\n        function getAndEncode(url) {\n            let cacheEntry = domtoimage.impl.urlCache.find(function (el) {\n                return el.url === url;\n            });\n\n            if (!cacheEntry) {\n                cacheEntry = {\n                    url: url,\n                    promise: null\n                };\n                domtoimage.impl.urlCache.push(cacheEntry);\n            }\n\n            if (cacheEntry.promise === null) {\n                if (domtoimage.impl.options.cacheBust) {\n                    // Cache bypass so we dont have CORS issues with cached images\n                    // Source: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n                    url += ((/\\?/).test(url) ? '&' : '?') + (new Date()).getTime();\n                }\n\n                cacheEntry.promise = new Promise(function (resolve) {\n                    const httpTimeout = domtoimage.impl.options.httpTimeout;\n                    const request = new XMLHttpRequest();\n\n                    request.onreadystatechange = done;\n                    request.ontimeout = timeout;\n                    request.responseType = 'blob';\n                    request.timeout = httpTimeout;\n                    if (domtoimage.impl.options.useCredentials) {\n                        request.withCredentials = true;\n                    }\n                    request.open('GET', url, true);\n                    request.send();\n\n                    let placeholder;\n                    if (domtoimage.impl.options.imagePlaceholder) {\n                        const split = domtoimage.impl.options.imagePlaceholder.split(/,/);\n                        if (split && split[1]) {\n                            placeholder = split[1];\n                        }\n                    }\n\n                    function done() {\n                        if (request.readyState !== 4) { return; }\n\n                        if (request.status !== 200) {\n                            if (placeholder) {\n                                resolve(placeholder);\n                            } else {\n                                fail(`cannot fetch resource: ${url}, status: ${request.status}`);\n                            }\n\n                            return;\n                        }\n\n                        const encoder = new FileReader();\n                        encoder.onloadend = function () {\n                            resolve(encoder.result);\n                        };\n                        encoder.readAsDataURL(request.response);\n                    }\n\n                    function timeout() {\n                        if (placeholder) {\n                            resolve(placeholder);\n                        } else {\n                            fail(`timeout of ${httpTimeout}ms occured while fetching resource: ${url}`);\n                        }\n                    }\n\n                    function fail(message) {\n                        console.error(message);\n                        resolve('');\n                    }\n                });\n            }\n            return cacheEntry.promise;\n        }\n\n        function escapeRegEx(string) {\n            return string.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n        }\n\n        function delay(ms) {\n            return function (arg) {\n                return new Promise(function (resolve) {\n                    setTimeout(function () {\n                        resolve(arg);\n                    }, ms);\n                });\n            };\n        }\n\n        function asArray(arrayLike) {\n            const array = [];\n            const length = arrayLike.length;\n            for (let i = 0; i < length; i++) {\n                array.push(arrayLike[i]);\n            }\n\n            return array;\n        }\n\n        function escapeXhtml(string) {\n            return string.replace(/%/g, \"%25\").replace(/#/g, '%23').replace(/\\n/g, '%0A');\n        }\n\n        function width(node) {\n            const width = px(node, \"width\");\n            if (isNaN(width)) {\n              const leftBorder = px(node, 'border-left-width');\n              const rightBorder = px(node, 'border-right-width');\n              return node.scrollWidth + leftBorder + rightBorder;\n            }\n            return width;\n        }\n\n        function height(node) {\n            const height = px(node, \"height\");\n            if (isNaN(height)) {\n              const topBorder = px(node, 'border-top-width');\n              const bottomBorder = px(node, 'border-bottom-width');\n              return node.scrollHeight + topBorder + bottomBorder;\n            }\n            return height;\n        }\n\n        function px(node, styleProperty) {\n            let value = getComputedStyle(node).getPropertyValue(styleProperty);\n            if (value.slice(-2) !== 'px') {\n            \treturn NaN;\n            }\n            value = value.slice(0, -2);\n            return parseFloat(value);\n        }\n    }\n\n    function newInliner() {\n        const URL_REGEX = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n\n        return {\n            inlineAll: inlineAll,\n            shouldProcess: shouldProcess,\n            impl: {\n                readUrls: readUrls,\n                inline: inline\n            }\n        };\n\n        function shouldProcess(string) {\n            return string.search(URL_REGEX) !== -1;\n        }\n\n        function readUrls(string) {\n            const result = [];\n            let match;\n            while ((match = URL_REGEX.exec(string)) !== null) {\n                result.push(match[1]);\n            }\n            return result.filter(function (url) {\n                return !util.isDataUrl(url);\n            });\n        }\n\n        function inline(string, url, baseUrl, get) {\n            return Promise.resolve(url)\n                .then(function (urlValue) {\n                    return baseUrl ? util.resolveUrl(urlValue, baseUrl) : urlValue;\n                })\n                .then(get || util.getAndEncode)\n                .then(function (dataUrl) {\n                    return string.replace(urlAsRegex(url), `\\$1${dataUrl}\\$3`);\n                });\n\n            function urlAsRegex(urlValue) {\n                return new RegExp(`(url\\\\([\\'\"]?)(${util.escape(urlValue)})([\\'\"]?\\\\))`, 'g');\n            }\n        }\n\n        function inlineAll(string, baseUrl, get) {\n            if (nothingToInline()) { return Promise.resolve(string); }\n\n            return Promise.resolve(string)\n                .then(readUrls)\n                .then(function (urls) {\n                    let done = Promise.resolve(string);\n                    urls.forEach(function (url) {\n                        done = done.then(function (prefix) {\n                            return inline(prefix, url, baseUrl, get);\n                        });\n                    });\n                    return done;\n                });\n\n            function nothingToInline() {\n                return !shouldProcess(string);\n            }\n        }\n    }\n\n    function newFontFaces() {\n        return {\n            resolveAll: resolveAll,\n            impl: {\n                readAll: readAll\n            }\n        };\n\n        function resolveAll() {\n            return readAll()\n                .then(function (webFonts) {\n                    return Promise.all(\n                        webFonts.map(function (webFont) {\n                            return webFont.resolve();\n                        })\n                    );\n                })\n                .then(function (cssStrings) {\n                    return cssStrings.join('\\n');\n                });\n        }\n\n        function readAll() {\n            return Promise.resolve(util.asArray(document.styleSheets))\n                .then(getCssRules)\n                .then(selectWebFontRules)\n                .then(function (rules) {\n                    return rules.map(newWebFont);\n                });\n\n            function selectWebFontRules(cssRules) {\n                return cssRules\n                    .filter(function (rule) {\n                        return rule.type === CSSRule.FONT_FACE_RULE;\n                    })\n                    .filter(function (rule) {\n                        return inliner.shouldProcess(rule.style.getPropertyValue('src'));\n                    });\n            }\n\n            function getCssRules(styleSheets) {\n                const cssRules = [];\n                styleSheets.forEach(function (sheet) {\n                    if (Object.getPrototypeOf(sheet).hasOwnProperty(\"cssRules\")) {\n                        try {\n                            util.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules));\n                        } catch (e) {\n                            console.log(`Error while reading CSS rules from ${sheet.href}`, e.toString());\n                        }\n                    }\n                });\n                return cssRules;\n            }\n\n            function newWebFont(webFontRule) {\n                return {\n                    resolve: function resolve() {\n                        const baseUrl = (webFontRule.parentStyleSheet || {}).href;\n                        return inliner.inlineAll(webFontRule.cssText, baseUrl);\n                    },\n                    src: function () {\n                        return webFontRule.style.getPropertyValue('src');\n                    }\n                };\n            }\n        }\n    }\n\n    function newImages() {\n        return {\n            inlineAll: inlineAll,\n            impl: {\n                newImage: newImage\n            }\n        };\n\n        function newImage(element) {\n            return {\n                inline: inline\n            };\n\n            function inline(get) {\n                if (util.isDataUrl(element.src)) { return Promise.resolve(); }\n\n                return Promise.resolve(element.src)\n                    .then(get || util.getAndEncode)\n                    .then(function (dataUrl) {\n                        return new Promise(function (resolve) {\n                            element.onload = resolve;\n                            // for any image with invalid src(such as <img src />), just ignore it\n                            element.onerror = resolve;\n                            element.src = dataUrl;\n                        });\n                    });\n            }\n        }\n\n        function inlineAll(node) {\n            if (!util.isElement(node)) { return Promise.resolve(node); }\n\n            return inlineCSSProperty(node)\n                .then(function () {\n                    if (util.isHTMLImageElement(node)) {\n                        return newImage(node).inline();\n                    } else {\n                        return Promise.all(\n                            util.asArray(node.childNodes).map(function (child) {\n                                return inlineAll(child);\n                            })\n                        );\n                    }\n                });\n\n            function inlineCSSProperty(node) {\n                const properties = ['background', 'background-image'];\n\n                const inliningTasks = properties.map(function (propertyName) {\n                    const value = node.style.getPropertyValue(propertyName);\n                    const priority = node.style.getPropertyPriority(propertyName);\n\n                    if (!value) {\n                        return Promise.resolve();\n                    }\n\n                    return inliner.inlineAll(value)\n                        .then(function (inlinedValue) {\n                            node.style.setProperty(\n                                propertyName,\n                                inlinedValue,\n                                priority\n                            );\n                        });\n                });\n\n                return Promise.all(inliningTasks)\n                    .then(function () {\n                        return node;\n                    });\n            }\n        }\n    }\n\n    function setStyleProperty(targetStyle, name, value, priority) {\n        const needs_prefixing = ['background-clip'].indexOf(name) >= 0;\n        if (priority) {\n            targetStyle.setProperty(name, value, priority);\n            if (needs_prefixing) {\n                targetStyle.setProperty(`-webkit-${name}`, value, priority);\n            }\n        } else {\n            targetStyle.setProperty(name, value);\n            if (needs_prefixing) {\n                targetStyle.setProperty(`-webkit-${name}`, value);\n            }\n        }\n    }\n\n    function copyUserComputedStyleFast(sourceComputedStyles, parentComputedStyles, targetElement) {\n        const defaultStyle = getDefaultStyle(targetElement.tagName);\n        const targetStyle = targetElement.style;\n\n        util.asArray(sourceComputedStyles).forEach(function (name) {\n            const sourceValue = sourceComputedStyles.getPropertyValue(name);\n            const defaultValue = defaultStyle[name];\n            const parentValue = parentComputedStyles ? parentComputedStyles.getPropertyValue(name) : undefined;\n\n            // If the style does not match the default, or it does not match the parent's, set it. We don't know which\n            // styles are inherited from the parent and which aren't, so we have to always check both.\n            if (sourceValue !== defaultValue ||\n                (parentComputedStyles && sourceValue !== parentValue)) {\n                const priority = sourceComputedStyles.getPropertyPriority(name);\n                setStyleProperty(targetStyle, name, sourceValue, priority);\n            }\n        });\n    }\n\n    let removeDefaultStylesTimeoutId = null;\n    let sandbox = null;\n    let tagNameDefaultStyles = {};\n\n    function getDefaultStyle(tagName) {\n        if (tagNameDefaultStyles[tagName]) {\n            return tagNameDefaultStyles[tagName];\n        }\n\n        // We haven't cached the answer for this tag yet, build a\n        // sandbox (if not yet created), fill it with the element\n        // and grab the default styles associated\n        const sandboxWindow = ensureSandboxWindow();\n        const sandboxDocument = sandboxWindow.document;\n        const defaultElement = constructElement(sandboxDocument, tagName);\n        const defaultStyle = computeStyleForDefaults(sandboxWindow, defaultElement);\n        destroyElement(sandboxDocument, defaultElement);\n\n        tagNameDefaultStyles[tagName] = defaultStyle;\n        return defaultStyle;\n\n        function ensureSandboxWindow() {\n            if (sandbox) {\n                return sandbox.contentWindow;\n            }\n\n            // figure out how this document is defined (doctype and charset)\n            const charsetToUse = document.characterSet || 'UTF-8';\n            const docType = document.doctype;\n            const docTypeDeclaration = docType\n                ? `<!DOCTYPE ${escapeHTML(docType.name)} ${escapeHTML(docType.publicId)} ${escapeHTML(docType.systemId)}`.trim() + '>'\n                : '';\n\n            // Create a hidden sandbox <iframe> element within we can create default HTML elements and query their\n            // computed styles. Elements must be rendered in order to query their computed styles. The <iframe> won't\n            // render at all with `display: none`, so we have to use `visibility: hidden` with `position: fixed`.\n            sandbox = document.createElement('iframe');\n            sandbox.id = 'domtoimage-sandbox-' + util.uid();\n            sandbox.style.visibility = 'hidden';\n            sandbox.style.position = 'fixed';\n            document.body.appendChild(sandbox);\n\n            return tryTechniques(\n                sandbox,\n                docTypeDeclaration,\n                charsetToUse,\n                'domtoimage-sandbox'\n            );\n\n            function escapeHTML(unsafeText) {\n                if (unsafeText) {\n                    const div = document.createElement('div');\n                    div.innerText = unsafeText;\n                    return div.innerHTML;\n                } else {\n                    return '';\n                }\n            }\n\n            function tryTechniques(sandbox, doctype, charset, title) {\n                // try the good old-fashioned document write with all the correct attributes set\n                try {\n                    sandbox.contentWindow.document.write(\n                        `${doctype}<html><head><meta charset='${charset}'><title>${title}</title></head><body></body></html>`\n                    );\n                    return sandbox.contentWindow;\n                } catch (_) {\n                    // swallow exception and fall through to next technique\n                }\n\n                const metaCharset = document.createElement('meta');\n                metaCharset.setAttribute('charset', charset);\n\n                // let's attempt it using srcdoc, so we can still set the doctype and charset\n                try {\n                    const sandboxDocument =\n                        document.implementation.createHTMLDocument(title);\n                    sandboxDocument.head.appendChild(metaCharset);\n                    const sandboxHTML =\n                        doctype + sandboxDocument.documentElement.outerHTML;\n                    sandbox.setAttribute('srcdoc', sandboxHTML);\n                    return sandbox.contentWindow;\n                } catch (_) {\n                    // swallow exception and fall through to the simplest path\n                }\n\n                // let's attempt it using contentDocument... here we're not able to set the doctype\n                sandbox.contentDocument.head.appendChild(metaCharset);\n                sandbox.contentDocument.title = title;\n                return sandbox.contentWindow;\n            }\n        }\n\n        function constructElement(sandboxDocument, tagName) {\n            const defaultElement = sandboxDocument.createElement(tagName);\n            sandboxDocument.body.appendChild(defaultElement);\n            // Ensure that there is some content, so that properties like margin are applied.\n            // we use zero-width space to handle FireFox adding a pixel\n            defaultElement.textContent = '\\u200b';\n            return defaultElement;\n        }\n\n        function computeStyleForDefaults(sandboxWindow, defaultElement) {\n            const defaultStyle = {};\n            const defaultComputedStyle = sandboxWindow.getComputedStyle(defaultElement);\n            // Copy styles to an object, making sure that 'width' and 'height' are given the default value of 'auto', since\n            // their initial value is always 'auto' despite that the default computed value is sometimes an absolute length.\n            util.asArray(defaultComputedStyle).forEach(function (name) {\n                defaultStyle[name] =\n                    (name === 'width' || name === 'height') ? 'auto' : defaultComputedStyle.getPropertyValue(name);\n            });\n            return defaultStyle;\n        }\n\n        function destroyElement(sandboxDocument, defaultElement) {\n            sandboxDocument.body.removeChild(defaultElement);\n        }\n    }\n\n    function removeSandbox() {\n        if (sandbox) {\n            document.body.removeChild(sandbox);\n            sandbox = null;\n        }\n        if (removeDefaultStylesTimeoutId) {\n            clearTimeout(removeDefaultStylesTimeoutId);\n        }\n        removeDefaultStylesTimeoutId = setTimeout(() => {\n            removeDefaultStylesTimeoutId = null;\n            tagNameDefaultStyles = {};\n        }, 20 * 1000);\n    }\n})(this);\n"],
  "mappings": "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",
  "names": ["global", "util", "let", "uid_index", "escape", "string", "replace", "isDataUrl", "url", "search", "canvasToBlob", "canvas", "toBlob", "Promise", "resolve", "binaryString", "atob", "toDataURL", "split", "length", "binaryArray", "Uint8Array", "i", "charCodeAt", "Blob", "type", "resolveUrl", "baseUrl", "doc", "document", "implementation", "createHTMLDocument", "base", "createElement", "a", "head", "appendChild", "body", "href", "getAndEncode", "cacheEntry", "domtoimage", "impl", "urlCache", "find", "el", "promise", "push", "options", "cacheBust", "test", "Date", "getTime", "httpTimeout", "request", "XMLHttpRequest", "onreadystatechange", "readyState", "status", "placeholder", "fail", "encoder", "FileReader", "onloadend", "result", "readAsDataURL", "response", "ontimeout", "responseType", "timeout", "useCredentials", "withCredentials", "open", "send", "message", "console", "error", "imagePlaceholder", "uid", "Math", "random", "pow", "toString", "slice", "delay", "ms", "arg", "setTimeout", "asArray", "arrayLike", "array", "escapeXhtml", "makeImage", "uri", "reject", "image", "Image", "crossOrigin", "onload", "window", "requestAnimationFrame", "onerror", "src", "width", "node", "px", "leftBorder", "rightBorder", "isNaN", "scrollWidth", "height", "topBorder", "bottomBorder", "scrollHeight", "getWindow", "isElement", "value", "Element", "isHTMLElement", "HTMLElement", "isHTMLCanvasElement", "HTMLCanvasElement", "isHTMLInputElement", "HTMLInputElement", "isHTMLImageElement", "HTMLImageElement", "isHTMLTextAreaElement", "HTMLTextAreaElement", "isSVGElement", "SVGElement", "isSVGRectElement", "SVGRectElement", "ownerDocument", "undefined", "defaultView", "styleProperty", "getComputedStyle", "getPropertyValue", "NaN", "parseFloat", "inliner", "URL_REGEX", "inlineAll", "get", "shouldProcess", "then", "readUrls", "urls", "done", "forEach", "prefix", "inline", "match", "exec", "filter", "urlValue", "dataUrl", "RegExp", "fontFaces", "resolveAll", "readAll", "webFonts", "all", "map", "webFont", "cssStrings", "join", "styleSheets", "cssRules", "sheet", "Object", "getPrototypeOf", "hasOwnProperty", "bind", "e", "log", "rule", "CSSRule", "FONT_FACE_RULE", "style", "rules", "newWebFont", "webFontRule", "parentStyleSheet", "cssText", "images", "inlineCSSProperty", "newImage", "childNodes", "child", "properties", "inliningTasks", "propertyName", "priority", "getPropertyPriority", "inlinedValue", "setProperty", "element", "defaultOptions", "toSvg", "toPng", "draw", "toJpeg", "quality", "toPixelData", "getContext", "getImageData", "data", "toCanvas", "exports", "module", "ownerWindow", "copyOptions", "clonee", "cloneNode", "root", "parentComputedStyles", "tagName", "makeNodeCopy", "clone", "cloneChildren", "processClone", "original", "children", "cloneChildrenInOrder", "parent", "childs", "computedStyles", "childClone", "cloneStyle", "clonePseudoElements", "copyUserInput", "fixSvg", "copyFont", "source", "target", "font", "fontFamily", "fontFeatureSettings", "fontKerning", "fontSize", "fontStretch", "fontStyle", "fontVariant", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariationSettings", "fontWeight", "copyStyle", "sourceElement", "targetElement", "sourceComputedStyles", "copyUserComputedStyleFast", "t", "removeProperty", "prop", "cloneClassName", "clonePseudoElement", "content", "formatPseudoElementStyle", "selector", "formatCssText", "formatCssProperties", "createTextNode", "styleText", "formatProperty", "name", "propertyValue", "propertyPriority", "n", "currentClass", "getAttribute", "styleElement", "setAttribute", "innerHTML", "attribute", "embedFonts", "inlineImages", "bgcolor", "backgroundColor", "keys", "property", "onCloneResult", "onclone", "svg", "XMLSerializer", "serializeToString", "xhtml", "foreignObject", "sandbox", "removeChild", "removeDefaultStylesTimeoutId", "clearTimeout", "tagNameDefaultStyles", "domNode", "scale", "ctx", "fillStyle", "fillRect", "msImageSmoothingEnabled", "imageSmoothingEnabled", "drawImage", "styleNode", "defaultStyle", "sandboxWindow", "contentWindow", "charsetToUse", "characterSet", "docType", "doctype", "docTypeDeclaration", "escapeHTML", "publicId", "systemId", "trim", "id", "visibility", "position", "charset", "title", "write", "_", "metaCharset", "sandboxDocument", "sandboxHTML", "documentElement", "outerHTML", "contentDocument", "unsafeText", "div", "innerText", "defaultElement", "textContent", "defaultComputedStyle", "targetStyle", "needs_prefixing", "sourceValue", "defaultValue", "parentValue", "indexOf", "this"]
}
